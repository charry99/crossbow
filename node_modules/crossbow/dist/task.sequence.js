"use strict";
var task_resolve_1 = require("./task.resolve");
var _ = require("../lodash.custom");
var Rx = require("rx");
var Observable = Rx.Observable;
var adaptors = require("./adaptors");
var Immutable = require("immutable");
var task_sequence_factories_1 = require("./task.sequence.factories");
var task_runner_1 = require("./task.runner");
var task_utils_1 = require("./task.utils");
function createFlattenedSequence(tasks, trigger) {
    return flatten(tasks, []);
    function flatten(items, initial, options, viaName) {
        return items.reduce(function (all, task) {
            /**
             * If the current task has child tasks, we build a tree of
             * nested observables for it (a task with children cannot itself
             * be a task that should be run)
             */
            if (task.type === task_resolve_1.TaskTypes.TaskGroup || task.type === task_resolve_1.TaskTypes.ParentGroup) {
                /**
                 * If we're looking at a group of tasks that was run
                 * with sub-tasks, we need to resolve differently to
                 * allow things such as parallel running to work as expected
                 */
                if (task.subTasks.length && task.tasks.length) {
                    /**
                     * Build the list of tasks/groups
                     * @type {Array}
                     */
                    var output = resolveGroupOfTasks(task, trigger.input);
                    /**
                     * Wrap as parallel group if this task has a runMode of 'parallel'
                     */
                    if (task.runMode === task_resolve_1.TaskRunModes.parallel) {
                        return all.concat(task_sequence_factories_1.createSequenceParallelGroup({
                            taskName: task.taskName,
                            items: output,
                            skipped: task.skipped
                        }));
                    }
                    /**
                     * Wrap as a series group if this task has a runMode of 'series'
                     */
                    if (task.runMode === task_resolve_1.TaskRunModes.series) {
                        return all.concat(task_sequence_factories_1.createSequenceSeriesGroup({
                            taskName: task.taskName,
                            items: output,
                            skipped: task.skipped
                        }));
                    }
                }
                /**
                 * If the current task was marked as `parallel`, all immediate children
                 * of (this task) will be run in `parallel`
                 */
                if (task.runMode === task_resolve_1.TaskRunModes.parallel) {
                    return all.concat(resolveGroup(task, task_sequence_factories_1.createSequenceParallelGroup));
                }
                /**
                 * If the current task was marked as `series`, all immediate child tasks
                 * will be queued and run in series - each waiting until the previous
                 * one has completed
                 */
                if (task.runMode === task_resolve_1.TaskRunModes.series) {
                    return all.concat(resolveGroup(task, task_sequence_factories_1.createSequenceSeriesGroup));
                }
            }
            /**
             * At this point, we must be dealing with a task that should be run,
             * so we first check if it's an adaptor @ task first
             */
            if (task.type === task_resolve_1.TaskTypes.Adaptor) {
                return all.concat(getSequenceItemWithOptions(task, trigger, adaptors[task.adaptor].create(task, trigger), {}));
            }
            /**
             * Finally, if the does not have children tasks & is not an
             * adaptor task it must have at least 1 associated module
             * (or an inline function) so we can begin working with it
             * by first resolving the top-level options object for it.
             */
            var localOptions = _.assign({}, loadTopLevelOptions(task, trigger), options);
            /**
             * Decide where the callable function is coming from
             * (inline function, external task etc)
             * @type {CBFunction}
             */
            var callable = (function () {
                if (task.type === task_resolve_1.TaskTypes.InlineFunction) {
                    return task.inlineFunctions[0];
                }
                return require(task.externalTasks[0].resolved);
            })();
            /**
             * Take the callable and create items with it + options
             */
            return all.concat(resolveFromFunction(task, callable, trigger, localOptions, viaName));
        }, initial);
    }
    /**
     * Resolve a group of tasks
     * @param task
     * @param groupCreatorFn
     * @param continueFn
     * @returns {any}
     */
    function resolveGroup(task, groupCreatorFn) {
        /**
         * If the group contains no subtasks
         */
        if (!task.subTasks.length) {
            /**
             * If a group has _default options,
             * but here no 'subTasks' were given, use the
             * default options always
             */
            var parentOptions = (function () {
                if (task.options._default !== undefined) {
                    return _.merge({}, task.options._default, task.query, task.flags);
                }
                return task.options;
            })();
            /**
             * Here the group had no direct 'sub tasks', so just return the item
             */
            return [groupCreatorFn({
                    taskName: task.taskName,
                    items: flatten(task.tasks, [], parentOptions),
                    skipped: task.skipped
                })];
        }
        /**
         * Use either subtasks directly, or if '*' was given, use
         * each key in the object to create a task
         */
        var lookupKeys = getLookupKeys(task.subTasks, task.options);
        /**
         * Now for each sub-task create a separate task item
         */
        return lookupKeys.map(function (subTaskName) {
            /**
             * When things like options, flags or query strings
             * were present on this task-group - pass them into the upcoming task instead
             * Order of presedence
             *   flags -> query -> options -> shared
             */
            var taskOptions = _.merge({}, task.options._default, _.get(task.options, subTaskName, {}), task.query, task.flags);
            return groupCreatorFn({
                taskName: task.taskName,
                items: flatten(task.tasks, [], taskOptions, task.taskName + ":" + subTaskName),
                skipped: task.skipped,
                subTaskName: subTaskName
            });
        });
    }
    function resolveGroupOfTasks(task, input) {
        if (task.type === task_resolve_1.TaskTypes.ParentGroup) {
            var opts = _.merge({}, task.options._default, task.query, task.flags);
            return flatten(task.tasks, [], opts, task.taskName);
        }
        var lookupKeys = getLookupKeys(task.subTasks, task.options);
        return lookupKeys.reduce(function (acc, subTaskName) {
            var opts = _.merge({}, task.options._default, _.get(task.options, subTaskName, {}), _.get(input.options, [task.baseTaskName, subTaskName], {}), task.query, task.flags);
            return acc.concat(flatten(task.tasks, [], opts, task.taskName + ":" + subTaskName));
        }, []);
    }
}
exports.createFlattenedSequence = createFlattenedSequence;
function resolveFromFunction(task, callable, trigger, localOptions, viaName) {
    /**
     * If the current item has no sub-tasks, we can return early
     * with a simple task creation using the global options
     *
     * eg:
     *      $ crossbow run sass
     *
     * options:
     *      sass:
     *        input:  "core.scss"
     *        output: "core.css"
     *
     * -> `sass` task will be run with the options
     *    {input: "core.scss", output: "core.css"}
     */
    if (!task.subTasks.length) {
        return getSequenceItemWithOptions(task, trigger, callable, localOptions, viaName);
    }
    /**
     * Get lookup keys for this task
     */
    var lookupKeys = getLookupKeys(task.subTasks, localOptions);
    /**
     * Now generate 1 task per lookup key.
     */
    var group = lookupKeys.reduce(function (acc, optionKey) {
        /**
         * `optionKey` here will be a string that represented the subTask
         * name, so we use that to try and find a child key
         * in the options that matched it.
         * */
        var currentOptionObject = _.merge({}, localOptions._default, _.get(localOptions, optionKey));
        var sequenceItems = getSequenceItemWithOptions(task, trigger, callable, currentOptionObject, optionKey)
            .map(function (seqItem) {
            seqItem.subTaskName = optionKey;
            return seqItem;
        });
        return acc.concat(sequenceItems);
    }, []);
    /**
     * Don't create a 'group' if we're only talking about 1 item
     */
    if (group.length === 1) {
        return group;
    }
    if (task.runMode === task_resolve_1.TaskRunModes.parallel) {
        return [task_sequence_factories_1.createSequenceParallelGroup({
                taskName: task.taskName,
                items: group,
                skipped: task.skipped
            })];
    }
    /**
     * If the current task was marked as `series`, all immediate child tasks
     * will be queued and run in series - each waiting until the previous
     * one has completed
     */
    if (task.runMode === task_resolve_1.TaskRunModes.series) {
        return [task_sequence_factories_1.createSequenceSeriesGroup({
                taskName: task.taskName,
                items: group,
                skipped: task.skipped
            })];
    }
}
function getSequenceItemWithOptions(task, trigger, imported, options, viaName) {
    /**
     * Merge incoming options with query + flags
     * eg:
     *     $  sass?input=css/core.css --production
     *     -> sass
     *          input: css/core.css
     *          production: true
     */
    var mergedOptionsWithQuery = _.merge({}, options, task.options, task.query, task.flags);
    /**
     * If the module did not export a function, but has a 'tasks'
     * property that is an array, use each function from it
     * eg:
     *  module.exports.tasks = [sass, cssmin, version-rev]
     */
    if (imported.tasks && Array.isArray(imported.tasks)) {
        return imported.tasks.map(function (importedFn, i) {
            return task_sequence_factories_1.createSequenceTaskItem({
                fnName: getFunctionName(imported, i + 1),
                factory: importedFn,
                task: task,
                options: mergedOptionsWithQuery,
                viaName: viaName
            });
        });
    }
    /**
     * If the module exported a function, use that as the factory
     * and return a single task for it.
     * eg:
     *  module.exports = function runSass() {}
     */
    if (typeof imported === "function") {
        return [task_sequence_factories_1.createSequenceTaskItem({
                fnName: getFunctionName(imported, 0),
                factory: imported,
                task: task,
                options: mergedOptionsWithQuery,
                viaName: viaName
            })];
    }
}
/**
 * For reporting purposes, try to 'name' a function
 */
function getFunctionName(fn, count) {
    if (count === void 0) { count = 0; }
    if (fn.name === undefined) {
        return "Anonymous Function " + count;
    }
    return fn.name;
}
/**
 *           ******************
 * Where the **--~~Magic~~--** happens!!!
 *           ******************
 *
 * Creating a task runner in crossbow is really about
 * wrapping the process of running the tasks in a way
 * that allows comprehensive logging/reporting
 *
 * Series & Parallel have different semantics and are
 * therefor handled separately.
 *
 * Note that everything here is completely lazy and
 * nothing will be executed until a user calls subscribe
 */
function createRunner(items, trigger) {
    return {
        sequence: items,
        series: function (ctx) {
            if (!ctx)
                ctx = Immutable.Map({});
            var flattened = createObservableTree(items, [], false, ctx);
            var run = Observable
                .from(flattened)
                .concatAll()
                .catch(function (x) { return Rx.Observable.empty(); });
            return run;
        },
        parallel: function (ctx) {
            if (!ctx)
                ctx = Immutable.Map({});
            var flattened = createObservableTree(items, [], true, ctx);
            var run = Observable.from(flattened).mergeAll();
            return run;
        }
    };
    /**
     * Any task in 'Parallel' run mode that throws an
     * error should not adversely affect sibling tasks
     */
    function shouldCatch(trigger) {
        return trigger.config.runMode === task_resolve_1.TaskRunModes.parallel;
    }
    /**
     * Create a nested tree of Observables that can contain tasks
     * alongside parallel/series groups. To understand how this works
     * you can think of the following to be an accurate representation of
     * what this function produces:
     *
     * const out = [
     Observable.concat(
     task1(),
     task2()
     ),
     Observable.concat(
     task3(),
     task4(),
     Observable.concat(
     task5(),
     task6(),
     task7()
     )
     )
     ];
     *
     */
    function createObservableTree(items, initial, addCatch, ctx) {
        if (addCatch === void 0) { addCatch = false; }
        return items.reduce(function (all, item) {
            var output;
            /**
             * If the current task was marked as `parallel`, all immediate children
             * of (this task) will be run in `parallel`
             */
            if (item.type === task_sequence_factories_1.SequenceItemTypes.ParallelGroup) {
                output = Observable.merge(createObservableTree(item.items, [], shouldCatch(trigger), ctx));
            }
            /**
             * If the current task was marked as `series`, all immediate child tasks
             * will be queued and run in series - each waiting until the previous
             * one has completed
             */
            if (item.type === task_sequence_factories_1.SequenceItemTypes.SeriesGroup) {
                output = Observable.concat(createObservableTree(item.items, [], false, ctx));
            }
            /**
             * Finally is item is a task, create an observable for it.
             */
            if (item.type === task_sequence_factories_1.SequenceItemTypes.Task && item.factory) {
                output = task_runner_1.createObservableFromSequenceItem(item, trigger, ctx);
            }
            /**
             * Should we add a catch clause to this item to enable
             * siblings to continue when a task errors
             */
            if (addCatch || !trigger.config.fail) {
                return all.concat(output.catch(function (x) { return Rx.Observable.empty(); }));
            }
            return all.concat(output);
        }, initial);
    }
}
exports.createRunner = createRunner;
/**
 * From user input, try to locate a options object
 */
function loadTopLevelOptions(task, trigger) {
    // todo - more robust way of matching options -> tasks
    var fullMatch = _.get(trigger.input.options, [task.taskName]);
    if (fullMatch !== undefined) {
        /**
         * If this item was given as top-level + options
         * just return the options here
         */
        if (fullMatch.options && fullMatch.tasks) {
            return fullMatch.options;
        }
        /**
         * If this task has a _default key, don't pass
         * all the options in, just pass the stuff under default
         */
        if (task.subTasks.length === 0 && fullMatch._default !== undefined) {
            return fullMatch._default;
        }
        return fullMatch;
    }
    if (task_utils_1.isInternal(task.rawInput)) {
        var lookup = task.taskName.replace(/(.+?)_internal_fn_\d{0,10}/, "");
        var fromInternal = _.get(trigger.input.options, [lookup]);
        if (fromInternal !== undefined) {
            return fromInternal;
        }
    }
    return {};
}
/**
 * After a bunch of tasks have run, we need to link up task-ended reports
 * with their original position in the sequence. This will allow us to
 * reconstruct the task render-tree but also show any tasks that errored
 * or did not complete
 * @param sequence
 * @param reports
 * @returns {*}
 */
function decorateSequenceWithReports(sequence, reports) {
    return addMany(sequence, []);
    function addMany(sequence, initial) {
        return sequence.reduce(function (all, item) {
            var c = _.assign({}, item);
            if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
                c.stats = getMergedStats(item, reports);
                return all.concat(c);
            }
            else {
                c.items = addMany(item.items, []);
                return all.concat(c);
            }
        }, initial);
    }
}
exports.decorateSequenceWithReports = decorateSequenceWithReports;
/**
 * Look at every item in the sequence tree and count how many
 * error have occured
 */
function countSequenceErrors(items) {
    return items.reduce(function (acc, item) {
        if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
            var errors = _.get(item, "stats.errors", []);
            if (errors.length) {
                return acc + errors.length;
            }
            return acc;
        }
        return acc + countSequenceErrors(item.items);
    }, 0);
}
exports.countSequenceErrors = countSequenceErrors;
function collectSkippedTasks(items, initial) {
    return items.reduce(function (acc, item) {
        if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
            if (item.stats.skipped) {
                return acc.concat(item);
            }
            return acc;
        }
        return acc.concat(collectSkippedTasks(item.items, []));
    }, initial);
}
exports.collectSkippedTasks = collectSkippedTasks;
function collectRunnableTasks(items, initial) {
    return items.reduce(function (acc, item) {
        if (item.type === task_sequence_factories_1.SequenceItemTypes.Task) {
            return acc.concat(item);
        }
        return acc.concat(collectRunnableTasks(item.items, []));
    }, initial);
}
exports.collectRunnableTasks = collectRunnableTasks;
/**
 * Look at the reports array to find stats linked to a
 * given task
 */
function getMergedStats(item, reports) {
    var match = reports.filter(function (report) {
        return report.item.seqUID === item.seqUID;
    });
    var start = match.filter(function (x) { return x.type === task_runner_1.TaskReportType.start; })[0];
    var error = match.filter(function (x) { return x.type === task_runner_1.TaskReportType.error; })[0];
    var end = match.filter(function (x) { return x.type === task_runner_1.TaskReportType.end; })[0];
    if (start && end) {
        return _.assign({}, start.stats, end.stats);
    }
    if (start && error) {
        var duration = error.stats.endTime - start.stats.startTime;
        return _.assign({}, start.stats, error.stats, { duration: duration });
    }
    if (start) {
        return _.assign({}, start.stats);
    }
    return { item: item, errors: [] };
}
/**
 * When we know a task has `subTasks` we need to check if
 * if the first entry in the subTasks array is a `*` - then
 * the user wants to run all tasks under this options
 * object. So we need to get the keys and use each one as a lookup
 * on the local options. (minus any excluded tasks)
 *
 * eg:
 *     $ crossbow run sass:*
 *
 * options:
 *   sass:
 *     site:  {input: "core.scss"}
 *     debug: {input: "debug.scss"}
 *
 * lookupKeys = ['site', 'debug']
 */
var blacklistedSubTaskNames = ["_default"];
function getLookupKeys(subTasks, topLevelObject) {
    if (subTasks[0] === "*") {
        return Object.keys(topLevelObject)
            .filter(function (x) { return blacklistedSubTaskNames.indexOf(x) === -1; });
    }
    return subTasks;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFzay5zZXF1ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90YXNrLnNlcXVlbmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSwrQ0FBdUQ7QUFDdkQsSUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDdEMsSUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pCLElBQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUM7QUFFakMscUNBQXVDO0FBQ3ZDLHFDQUF3QztBQUl4QyxxRUFPbUM7QUFFbkMsNkNBQStFO0FBRS9FLDJDQUF3QztBQUV4QyxpQ0FBd0MsS0FBYSxFQUFFLE9BQXVCO0lBRTFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRTFCLGlCQUFpQixLQUFhLEVBQUUsT0FBdUIsRUFBRSxPQUFRLEVBQUUsT0FBUTtRQUV2RSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFDLEdBQUcsRUFBRSxJQUFVO1lBRWhDOzs7O2VBSUc7WUFDSCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLHdCQUFTLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssd0JBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO2dCQUUzRTs7OzttQkFJRztnQkFDSCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7b0JBRTVDOzs7dUJBR0c7b0JBQ0gsSUFBTSxNQUFNLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFFeEQ7O3VCQUVHO29CQUNILEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEtBQUssMkJBQVksQ0FBQyxRQUFR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