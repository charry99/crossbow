"use strict";
var file_utils_1 = require("./file.utils");
var reports = require("./reporter.resolve");
var task_utils_1 = require("./task.utils");
var _ = require("../lodash.custom");
/**
 * If the user has specified any `envFile` options,
 * we need to read each file from disk and parse it's data.
 * Finally we save the results on the incoming config object
 */
exports.addEnvFilesToObject = function (config) {
    return config.envFile.length
        ? exports.getEnvFiles(config.envFile, config.envFilePrefix, config.cwd)
            .map(function (envFiles) {
            return _.assign({}, config, {
                envFiles: envFiles
            });
        })
        : file_utils_1.Right(config);
};
/**
 * Either wrapper to handle the fact that 1 or more of the envFile
 * options could've resulted in an error.
 * If that's the case, we want to return a Left that has the report type
 * `EnvFileOptionError` so that a nice error can be printed
 */
exports.getEnvFiles = function (envFile, globalPrefix, cwd) {
    return file_utils_1.Right([].concat(envFile).map(function (path) { return exports.getSingleEnvFile(path, globalPrefix, cwd); }))
        .map(function (xs) {
        return {
            all: xs,
            valid: xs.filter(function (x) { return x.errors.length === 0; }),
            invalid: xs.filter(function (x) { return x.errors.length > 0; })
        };
    })
        .chain(function (x) { return x.invalid.length
        ? file_utils_1.Left({ type: reports.ReportTypes.EnvFileOptionError, data: x })
        : file_utils_1.Right(x.valid); });
};
/**
 * Given a single `envFile` option, try to read & parse
 * a file from disk.
 */
exports.getSingleEnvFile = function (envFile, globalPrefix, cwd) {
    return file_utils_1.Right(envFile)
        .chain(function (envFileItem) { return file_utils_1.Right([getLookupPath(envFileItem), getPrefix(envFileItem, globalPrefix)])
        .chain(function (_a) {
        var lookupPath = _a[0], prefix = _a[1];
        // Now attempt to read the file from disk
        return readEnvFile(lookupPath, cwd)
            .fold(function (file) {
            return file_utils_1.Left({
                input: lookupPath,
                file: file,
                prefix: prefix,
                errors: [{ type: task_utils_1.InputErrorTypes.EnvFileNotFound }]
            });
        }, function (r) { return file_utils_1.Right(r); }) // <-- otherwise continue with the result
            .chain(function (file) {
            // Try to parse the data from it. (JSON/env could throw)
            return file_utils_1.tryCatch(function () { return parseData(file); })
                .fold(function (error) { return file_utils_1.Left({
                input: lookupPath,
                file: file,
                prefix: prefix,
                errors: [{ type: task_utils_1.InputErrorTypes.EnvFileParseError, error: error }]
            }); }, 
            // If the content parsed without error, return the final result
            function (parsedData) { return file_utils_1.Right({
                input: lookupPath,
                file: _.assign({}, file, { data: parsedData }),
                prefix: prefix, errors: []
            }); });
        });
    }); }).fold(function (e) { return e; }, function (r) { return r; }); // finally fold as we could've exited early todo: could this be removed?
};
/**
 * Wrapper for reading the env file from disk.
 * The result could have an 'errors' property so we
 * wrap this in the Either type
 */
var readEnvFile = function (lookupPath, cwd) {
    return file_utils_1.Right(file_utils_1.readFileFromDiskWithContent(lookupPath, cwd))
        .chain(function (result) { return result.errors.length
        ? file_utils_1.Left(result)
        : file_utils_1.Right(result); });
};
/**
 * Parse either json or regular .env file
 * @param file
 * @returns {any}
 */
function parseData(file) {
    if (file.parsed.ext === '.json') {
        return JSON.parse(file.content);
    }
    return file_utils_1.parseEnv(file.content);
}
/**
 * `envFile` could be either a string or object, so
 * we need to decide where to get the lookup path from
 *
 * -> envFile: package.json
 * -> envFile:
 *      path: package.json
 *      prefix: [npm, package]
 */
var getLookupPath = function (envFile) {
    return typeof envFile === 'string'
        ? envFile
        : envFile.path;
};
/**
 * envFiles can either have their own prefixes array, or
 * it will inherit from the global if not set.
 * @param envFile
 * @param globalPrefixes
 * @returns {any}
 */
var getPrefix = function (envFile, globalPrefixes) {
    if (typeof envFile === 'string') {
        return globalPrefixes;
    }
    if (envFile.prefix && envFile.prefix.length) {
        return [].concat(envFile.prefix);
    }
    return globalPrefixes;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0dXAuZW52RmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zZXR1cC5lbnZGaWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSwyQ0FBK0c7QUFDL0csNENBQThDO0FBRTlDLDJDQUE2QztBQUM3QyxJQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUV0Qzs7OztHQUlHO0FBQ1UsUUFBQSxtQkFBbUIsR0FBRyxVQUFBLE1BQU07SUFDckMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTTtVQUV0QixtQkFBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLGFBQWEsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDO2FBRTFELEdBQUcsQ0FBQyxVQUFBLFFBQVE7WUFDVCxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFO2dCQUN4QixRQUFRLEVBQUUsUUFBUTthQUNyQixDQUFDLENBQUM7UUFDUCxDQUFDLENBQUM7VUFDSixrQkFBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQztBQUVGOzs7OztHQUtHO0FBQ1UsUUFBQSxXQUFXLEdBQUcsVUFBQyxPQUFnQixFQUFFLFlBQXNCLEVBQUUsR0FBVztJQUM3RSxPQUFBLGtCQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSx3QkFBZ0IsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLEdBQUcsQ0FBQyxFQUF6QyxDQUF5QyxDQUFDLENBQUM7U0FDM0UsR0FBRyxDQUFDLFVBQUEsRUFBRTtRQUNILE1BQU0sQ0FBQztZQUNILEdBQUcsRUFBRSxFQUFFO1lBQ1AsS0FBSyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsTUFBTSxDQUFD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